import"./modulepreload-polyfill-B5Qt9EMX.js";import{m as xt}from"./mod-DTuQx7wz.js";function q(i){return Math.PI*i/180}function et([i,s,t]){return Math.hypot(i,s,t)}function K(i){const s=et(i);return i.map(t=>t/s)}function X([i,s,t]){return[i,s,t]}function j([i,s,t],[e,o,a]){return i*e+s*o+t*a}function W([i,s,t],[e,o,a]){return[s*a-t*o,t*e-i*a,i*o-s*e]}function y(i,s){return[i[0]*s,i[1]*s,i[2]*s]}function T(i,s){return[i[0]+s[0],i[1]+s[1],i[2]+s[2]]}function O(i,s){return[i[0]-s[0],i[1]-s[1],i[2]-s[2]]}function ht(i){const[s,t,e,o]=i;return[[s[0],t[0],e[0],o[0]],[s[1],t[1],e[1],o[1]],[s[2],t[2],e[2],o[2]],[s[3],t[3],e[3],o[3]]]}function dt(i,s,t,e){const o=1/Math.tan(i/2),a=e-t;return[[o/s,0,0,0],[0,o,0,0],[0,0,-(t+e)/a,-2*t*e/a],[0,0,-1,0]]}function pt(i,s,t){let e=K(O(s,i));const o=K(W(e,t)),a=K(W(o,e));if(!o.every(r=>r==r))throw"two parallel vectors were given";e=y(e,-1);const h=Et(-j(o,i),-j(a,i),-j(e,i)),n=[[o[0],o[1],o[2],0],[a[0],a[1],a[2],0],[e[0],e[1],e[2],0],[0,0,0,1]];return $(h,n)}function Et(i,s,t){return[[1,0,0,i],[0,1,0,s],[0,0,1,t],[0,0,0,1]]}function k(i,s){return i[0]*s[0]+i[1]*s[1]+i[2]*s[2]+i[3]*s[3]}function $(i,s){const[t,e,o,a]=i,[h,n,r,l]=ht(s);return[[k(t,h),k(t,n),k(t,r),k(t,l)],[k(e,h),k(e,n),k(e,r),k(e,l)],[k(o,h),k(o,n),k(o,r),k(o,l)],[k(a,h),k(a,n),k(a,r),k(a,l)]]}function tt(i,s){return[i[0],i[1],i[2],s]}function F(i){return[i[0],i[1],i[2]]}function B(i,s){const[t,e,o,a]=i;return[k(t,s),k(e,s),k(o,s),k(a,s)]}function rt([i,s,t],e){const o=(u,p,d)=>{const g=Math.sqrt(u*u+p*p+d*d);return[u/g,p/g,d/g]};let[a,h,n]=o(i,s,t),[r,l]=[Math.cos(e),Math.sin(e)],c=1-r;return[[a*a*c+r,a*h*c-n*l,a*n*c+h*l,0],[a*h*c+n*l,h*h*c+r,h*n*c-a*l,0],[a*n*c-h*l,h*n*c+a*l,n*n*c+r,0],[0,0,0,1]]}function at(i){const[s,t,e,o]=ht(i);return[...s,...t,...e,...o]}function mt(i,s,t){return Math.min(Math.max(i,s),t)}function it(i,s){if(!i)throw new Error(s)}function M(i,s){const t=i%s;return t<0?t+s:t}function vt(i,s){return Array(Math.max(s.length,i.length)).fill(void 0).map((t,e)=>[i[e],s[e]])}var w=(i=>(i[i.LEFT=0]="LEFT",i[i.RIGHT=1]="RIGHT",i[i.UP=2]="UP",i[i.DOWN=3]="DOWN",i[i.FRONT=4]="FRONT",i[i.BACK=5]="BACK",i))(w||{});function _t(i){switch(i){case 0:return[-1,0,0];case 1:return[1,0,0];case 2:return[0,-1,0];case 3:return[0,1,0];case 5:return[0,0,-1];case 4:return[0,0,1]}}class Tt{constructor(s,t){this.buildTextureAtlas=e=>{let o=e.createTexture();e.bindTexture(e.TEXTURE_2D_ARRAY,o),e.pixelStorei(e.UNPACK_ALIGNMENT,1),e.texParameteri(e.TEXTURE_2D_ARRAY,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D_ARRAY,e.TEXTURE_MAG_FILTER,e.NEAREST);const a=new Uint8Array(this.tileSize*this.tileSize*this.defs.length*6*4);e.texImage3D(e.TEXTURE_2D_ARRAY,0,e.RGBA,this.tileSize,this.tileSize,this.defs.length*6,0,e.RGBA,e.UNSIGNED_BYTE,a);for(let h=0;h<this.defs.length;h++){const n=this.defs[h];if(n.textures!==void 0)for(let r=0;r<n.textures.length;r++)e.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,h*6+r,this.tileSize,this.tileSize,1,e.RGBA,e.UNSIGNED_BYTE,n.textures[r])}return e.generateMipmap(e.TEXTURE_2D_ARRAY),o},this.tileSize=s,this.defs=t;for(let e=0;e<this.defs.length;e++){const o=this.defs[e];if(o.textures!==void 0)for(let a=0;a<o.textures.length;a++){const h=o.textures[a];it(h.height===s,`block #${e} face #${a} height != ${s}, found ${h.height}`),it(h.width===s,`block #${e} face #${a} width != ${s}, found ${h.width}`)}}}}function Y(i,s,t){const e=i.createShader(s);return i.shaderSource(e,t),i.compileShader(e),e}function ct(i,s,t){const e=i.createProgram();for(const a of s)i.attachShader(e,a);for(const[a,h]of t)i.bindAttribLocation(e,a,h);if(i.linkProgram(e),i.getProgramParameter(e,i.LINK_STATUS))return e;for(const a of s)i.getShaderParameter(a,i.COMPILE_STATUS)||console.log(i.getShaderInfoLog(a)),i.deleteShader(a);return console.log(i.getProgramInfoLog(e)),i.deleteProgram(e),null}const wt=1,kt=1,Rt=1,At=1,yt=1,L=16,b=16,A=16,lt=2,ut=2,ft=2,H=1,z=1,V=1,Z=512,J=1024,bt=`#version 300 es
precision highp int;
precision highp float;
uniform mat4 u_mvpMat;

in vec3 a_position;
out vec3 v_position;

in vec3 a_tuv;
out vec3 v_tuv;

in vec3 a_normal;
out vec3 v_normal;

void main() {
   v_tuv = a_tuv;
   v_normal = a_normal;
   v_position = a_position;
   // actual location
   gl_Position = u_mvpMat * vec4(a_position, 1.0);
}
`,Dt=`#version 300 es
precision highp int;
precision highp float;
precision highp isampler2D;
precision highp sampler2DArray;

// the texture atlas for the blocks
uniform sampler2DArray u_textureAtlas;

// Shared between all chunks
uniform sampler2DArray u_lightDepthArr;
uniform sampler2DArray u_lightDataArr;

// specific to the chunk.
// Contains 27 entries of start indexes and lengths
uniform isampler2D u_lightIndexes;

// position
in vec3 v_position;

// normal
in vec3 v_normal;

// texCoord
in vec3 v_tuv;

out vec4 v_outColor;

void main() {
  vec4 color = texture(u_textureAtlas, v_tuv);

  float lightSum = 0.2;

  int nLights = textureSize(u_lightIndexes, 0).x;
  for(int c = 0; c < nLights; c++) {
    int i = texelFetch(u_lightIndexes, ivec2(c, 0), 0).x;

    // get light position from texture
    vec3 lightPos = texelFetch(u_lightDataArr, ivec3(0, 0, i), 0).rgb;
    mat4 lightMvp = mat4(
        texelFetch(u_lightDataArr, ivec3(1, 0, i), 0),
        texelFetch(u_lightDataArr, ivec3(2, 0, i), 0),
        texelFetch(u_lightDataArr, ivec3(3, 0, i), 0),
        texelFetch(u_lightDataArr, ivec3(4, 0, i), 0)
    );
    vec4 lightSpacePosition = lightMvp * vec4(v_position, 1.0);

    vec3 projectedCoord = lightSpacePosition.xyz / lightSpacePosition.w;
    bool inRange =
        projectedCoord.z >= -1.0 &&
        projectedCoord.z <= 1.0 &&
        projectedCoord.x >= -1.0 &&
        projectedCoord.x <= 1.0 &&
        projectedCoord.y >= -1.0 &&
        projectedCoord.y <= 1.0;

    // remap coords to texCoords
    vec2 texCoord = (projectedCoord.xy + vec2(1.0, 1.0))/2.0;

    float depthMapDepth = texture(u_lightDepthArr, vec3(texCoord, i)).r;
    const float bias = 0.002;
    float currentDepth = (projectedCoord.z + 1.0)/2.0 - bias;

    if(inRange && currentDepth <= depthMapDepth) {
        float intensity = 1.0-currentDepth;
        vec3 lightDir = normalize(lightPos - v_position);
        float diffuseIntensity = max(dot(v_normal, lightDir), 0.0);
        lightSum += 7.0*diffuseIntensity*intensity;
    }
  }

  v_outColor = vec4(color.rgb*lightSum, color.a);
}
`,Lt=`#version 300 es
precision highp float;
in vec3 a_position;
uniform mat4 u_mvpMat;
void main() {
   gl_Position = u_mvpMat * vec4(a_position, 1.0);
}
`,Ct=`#version 300 es
precision highp float;
out vec4 v_outColor;
void main() {
  v_outColor = vec4(0.0, 0.0, 0.0, 1.0);
}
`;class It{constructor(s,t,e,o,a){this.POSITION_LOC=0,this.NORMAL_LOC=1,this.TUV_LOC=2,this.emptyChunk=new Uint16Array(L*b*A),this.getWorldChunkLoc=h=>[Math.floor(h[0]/L),Math.floor(h[1]/b),Math.floor(h[2]/A)],this.createGraphics=h=>{const n=this.gl.createVertexArray();this.gl.bindVertexArray(n);const r=this.gl.createBuffer();return this.gl.bindBuffer(this.gl.ARRAY_BUFFER,r),this.gl.bufferData(this.gl.ARRAY_BUFFER,h,this.gl.DYNAMIC_DRAW),this.gl.enableVertexAttribArray(this.POSITION_LOC),this.gl.vertexAttribPointer(this.POSITION_LOC,3,this.gl.FLOAT,!1,9*4,0*4),this.gl.enableVertexAttribArray(this.NORMAL_LOC),this.gl.vertexAttribPointer(this.NORMAL_LOC,3,this.gl.FLOAT,!1,9*4,3*4),this.gl.enableVertexAttribArray(this.TUV_LOC),this.gl.vertexAttribPointer(this.TUV_LOC,3,this.gl.FLOAT,!1,9*4,6*4),{vao:n,buffer:r,vertexCount:h.length/9}},this.deleteGraphics=h=>{this.gl.deleteBuffer(h.buffer),this.gl.deleteVertexArray(h.vao)},this.deleteChunkGraphics=h=>{this.deleteGraphics(h.solid),this.deleteGraphics(h.transparent)},this.deleteGPUData=h=>{this.gl.deleteTexture(h.lightIndexesTex)},this.shouldBeLoaded=h=>{const n=O(h,this.worldChunkCenterLoc);return n[0]>=-H&&n[0]<=H&&n[1]>=-z&&n[1]<=z&&n[2]>=-V&&n[2]<=V},this.shouldBeUnloaded=h=>{const n=O(h,this.worldChunkCenterLoc);return!(n[0]>=-lt&&n[0]<=lt&&n[1]>=-ut&&n[1]<=ut&&n[2]>=-ft&&n[2]<=ft)},this.unloadChunk=h=>{const n=this.chunk_map.get(h);n.graphics!==void 0&&this.deleteChunkGraphics(n.graphics),n.ownLights!==void 0&&this.freeLightIndexes.push(...n.ownLights.lightData.map(r=>r.index)),n.completeLighting!==void 0&&this.deleteGPUData(n.completeLighting.data);for(const r of this.adjacentChunkLocs(JSON.parse(h))){const l=this.chunk_map.get(JSON.stringify(r));l?.completeLighting!==void 0&&(l.completeLighting.stale=!0)}this.chunk_map.delete(h)},this.updateCameraLoc=()=>{for(const[r,l]of this.chunk_map)this.shouldBeUnloaded(JSON.parse(r))&&this.unloadChunk(r);for(let r=-H;r<=H;r++)for(let l=-z;l<=z;l++)for(let c=-V;c<=V;c++){const u=JSON.stringify(T(this.worldChunkCenterLoc,[r,l,c]));this.chunk_map.get(u)===void 0&&this.chunk_map.set(u,{})}const h=Array.from(this.chunk_map.keys(),r=>JSON.parse(r)).sort((r,l)=>{const c=et(O(r,this.worldChunkCenterLoc)),u=et(O(l,this.worldChunkCenterLoc));return c-u}),n=new Map;for(const r of h){const l=JSON.stringify(r);n.set(l,this.chunk_map.get(l))}this.chunk_map=n},this.addHighlight=(h,n)=>{const r=this.highlights.get(h);r!==void 0&&this.deleteGraphics(r);const l=this.createGraphics(st([{bi:6,cubeLoc:n.coords,face:n.face}]));this.highlights.set(h,l)},this.removeHighlight=h=>{const n=this.highlights.get(h);n!==void 0&&(this.deleteGraphics(n),this.highlights.delete(h))},this.createLightData=h=>{const n=T(h.cubeLoc,[.5,.5,.5]),r=dt(q(90),1,.5,10),l=h.face===w.UP||h.face===w.DOWN?[-1,0,0]:[0,-1,0],c=pt(n,T(n,_t(h.face)),l),u=$(r,c);return[n,u]},this.updateLightDataTex=(h,n)=>{const r=new Float32Array(20);{let[l,c]=n,[u,p,d,g]=ht(c);r.set(l,0),r.set(u,4),r.set(p,8),r.set(d,12),r.set(g,16)}this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY,this.lightDataTexArr),this.gl.texSubImage3D(this.gl.TEXTURE_2D_ARRAY,0,0,0,h,5,1,1,this.gl.RGBA,this.gl.FLOAT,r)},this.renderShadowMap=(h,n,r)=>{this.gl.useProgram(this.shadowProgram),this.gl.uniformMatrix4fv(this.shadowMvpMatLoc,!1,at(n)),this.gl.viewport(0,0,Z,Z),this.gl.enable(this.gl.DEPTH_TEST),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.shadowFbs[h]),this.gl.clear(this.gl.DEPTH_BUFFER_BIT);for(const l of r)this.gl.bindVertexArray(l.vao),this.gl.drawArrays(this.gl.TRIANGLES,0,l.vertexCount)},this.adjacentChunkLocs=h=>[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]].map(r=>T(h,r)),this.neighboringChunkLocs=h=>{const n=[];for(let r=-1;r<=1;r++)for(let l=-1;l<=1;l++)for(let c=-1;c<=1;c++)(c!==0||l!==0||r!==0)&&n.push(T(h,[r,l,c]));return n},this.getChunkBlocksIfExists=h=>{const n=this.chunk_map.get(JSON.stringify(h))?.blocks;return n||this.emptyChunk},this.update=h=>{let n=0;t:for(const[l,c]of this.chunk_map){const u=JSON.parse(l);if(c.blocks===void 0){c.blocks=Mt(u,this.noiseFn);for(const d of this.adjacentChunkLocs(u)){const g=this.chunk_map.get(JSON.stringify(d));g&&g.mesh&&(g.mesh.stale=!0)}n+=wt}if(n>1)break t;const p=[u[0]*L,u[1]*b,u[2]*A];if(c.mesh===void 0||c.mesh.stale){for(const f of this.adjacentChunkLocs(u))if(this.shouldBeLoaded(f)){const _=this.chunk_map.get(JSON.stringify(f));if(_===void 0||_.blocks===void 0)continue t}const{solid:d,transparent:g,lights:E}=St(p,this.blockManager,c.blocks,this.getChunkBlocksIfExists(T(u,[-1,0,0])),this.getChunkBlocksIfExists(T(u,[1,0,0])),this.getChunkBlocksIfExists(T(u,[0,-1,0])),this.getChunkBlocksIfExists(T(u,[0,1,0])),this.getChunkBlocksIfExists(T(u,[0,0,-1])),this.getChunkBlocksIfExists(T(u,[0,0,1])));c.mesh={solid:d,transparent:g,lights:E,stale:!1},c.graphics!==void 0&&(c.graphics.stale=!0),n+=kt}if(n>1)break t;if(c.graphics===void 0||c.graphics.stale){c.graphics!==void 0&&this.deleteChunkGraphics(c.graphics),c.graphics={solid:this.createGraphics(st(c.mesh.solid)),transparent:this.createGraphics(st(c.mesh.transparent)),stale:!1},c.ownLights!==void 0&&(c.ownLights.stale=!0);for(const d of this.neighboringChunkLocs(u)){const g=this.chunk_map.get(JSON.stringify(d));g&&g.ownLights&&(g.ownLights.stale=!0)}n+=Rt}if(n>1)break t;if(c.ownLights===void 0||c.ownLights.stale){const d=c.mesh.lights.map(this.createLightData);let g=!1;const E=c.ownLights===void 0?[]:c.ownLights.lightData.map(x=>x.index);let f=[];for(const[x,m]of vt(d,E))if(x!==void 0&&m!==void 0&&f.push({matLoc:x,index:m}),x===void 0&&m!==void 0)this.freeLightIndexes.push(m),g=!0;else if(x!==void 0&&m===void 0){const v=this.freeLightIndexes.pop();v!==void 0?(f.push({matLoc:x,index:v}),g=!0):console.log("Ran out of lights!")}c.ownLights={stale:!0,lightData:f};const _=[c.graphics.solid];for(const x of this.neighboringChunkLocs(u)){const m=this.chunk_map.get(JSON.stringify(x));m&&m.graphics&&_.push(m.graphics.solid)}for(const{index:x,matLoc:m}of c.ownLights.lightData)this.renderShadowMap(x,m[1],_),this.updateLightDataTex(x,m);if(g){c.completeLighting!==void 0&&(c.completeLighting.stale=!0);for(const x of this.neighboringChunkLocs(u)){const m=this.chunk_map.get(JSON.stringify(x));m&&m.completeLighting&&(m.completeLighting.stale=!0)}}c.ownLights.stale=!1,n+=At}if(n>1)break t;if(c.completeLighting===void 0||c.completeLighting.stale){c.completeLighting===void 0&&(c.completeLighting={stale:!0,data:{lightIndexesTex:this.gl.createTexture()}});const d=[u,...this.neighboringChunkLocs(u)].map(g=>this.chunk_map.get(JSON.stringify(g))?.ownLights?.lightData).flatMap(g=>g===void 0?[]:g.map(E=>E.index));console.log(d),this.gl.bindTexture(this.gl.TEXTURE_2D,c.completeLighting.data.lightIndexesTex),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.R32I,d.length,1,0,this.gl.RED_INTEGER,this.gl.INT,new Int32Array(d)),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),c.completeLighting.stale=!1,n+=yt}if(n>1)break t}const r=this.getWorldChunkLoc(h);(r[0]!==this.worldChunkCenterLoc[0]||r[1]!==this.worldChunkCenterLoc[1]||r[2]!==this.worldChunkCenterLoc[2])&&(this.worldChunkCenterLoc=r,this.updateCameraLoc())},this.render=h=>{this.gl.useProgram(this.renderProgram),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.uniformMatrix4fv(this.renderMvpMatLoc,!1,at(h)),this.gl.enable(this.gl.DEPTH_TEST),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY,this.textureAtlas),this.gl.activeTexture(this.gl.TEXTURE1),this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY,this.shadowTexArr),this.gl.activeTexture(this.gl.TEXTURE2),this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY,this.lightDataTexArr);for(const n of this.chunk_map.values())n.graphics!==void 0&&n.completeLighting!==void 0&&(this.gl.bindVertexArray(n.graphics.solid.vao),this.gl.activeTexture(this.gl.TEXTURE3),this.gl.bindTexture(this.gl.TEXTURE_2D,n.completeLighting.data.lightIndexesTex),this.gl.drawArrays(this.gl.TRIANGLES,0,n.graphics.solid.vertexCount));this.gl.depthMask(!1);for(const n of this.chunk_map.values())n.graphics!==void 0&&(this.gl.bindVertexArray(n.graphics.transparent.vao),this.gl.drawArrays(this.gl.TRIANGLES,0,n.graphics.transparent.vertexCount));this.gl.depthMask(!0),this.gl.disable(this.gl.DEPTH_TEST);for(const n of this.highlights.values())this.gl.bindVertexArray(n.vao),this.gl.drawArrays(this.gl.TRIANGLES,0,n.vertexCount)},this.getBlock=h=>{const n=this.chunk_map.get(JSON.stringify(this.getWorldChunkLoc(h)));return n&&n.blocks?n.blocks[R(M(h[0],L),M(h[1],b),M(h[2],A))]:null},this.setBlock=(h,n)=>{const r=u=>{const p=this.chunk_map.get(JSON.stringify(u));p&&p.mesh&&(p.mesh.stale=!0)},l=this.getWorldChunkLoc(h),c=this.chunk_map.get(JSON.stringify(l));if(c&&c.blocks){const u=Math.floor(M(h[0],L)),p=Math.floor(M(h[1],b)),d=Math.floor(M(h[2],A));return c.blocks[R(u,p,d)]=n,r(l),u===0&&r(T(l,[-1,0,0])),u===L-1&&r(T(l,[1,0,0])),p===0&&r(T(l,[0,-1,0])),p===b-1&&r(T(l,[0,1,0])),d===0&&r(T(l,[0,0,-1])),d===A-1&&r(T(l,[0,0,1])),!0}else return!1},this.intbound=(h,n)=>{const r=Math.round(h)==h;if(n<0&&r)return 0;let l;return h==0?l=1:l=Math.ceil(h),(n>0?l-h:h-Math.floor(h))/Math.abs(n)},this.castRay=(h,n,r)=>{let l=Math.floor(h[0]),c=Math.floor(h[1]),u=Math.floor(h[2]);const[p,d,g]=n,E=Math.sign(p),f=Math.sign(d),_=Math.sign(g);let x=this.intbound(h[0],p),m=this.intbound(h[1],d),v=this.intbound(h[2],g);const C=E/p,I=f/d,nt=_/g;it(j(n,n)!==0,"direction vector is 0");const G=r/Math.sqrt(p*p+d*d+g*g);let P=w.UP;for(;;){const ot=this.getBlock([l,c,u]);if(ot===null)break;if(this.blockManager.defs[ot].pointable)return{coords:[l,c,u],face:P};if(x<m)if(x<v){if(x>G)break;l+=E,x+=C,P=E==1?w.LEFT:w.RIGHT}else{if(v>G)break;u+=_,v+=nt,P=_==1?w.BACK:w.FRONT}else if(m<v){if(m>G)break;c+=f,m+=I,P=f==1?w.UP:w.DOWN}else{if(v>G)break;u+=_,v+=nt,P=_==1?w.BACK:w.FRONT}}return null},this.gl=e,this.blockManager=o,this.seed=s,this.noiseFn=xt.makeNoise3D(s),this.worldChunkCenterLoc=this.getWorldChunkLoc(t),this.chunk_map=new Map,this.highlights=new Map,this.textureAtlas=this.blockManager.buildTextureAtlas(this.gl),this.renderProgram=ct(this.gl,[Y(this.gl,this.gl.VERTEX_SHADER,bt),Y(this.gl,this.gl.FRAGMENT_SHADER,Dt)],new Map([[this.POSITION_LOC,"a_position"],[this.NORMAL_LOC,"a_normal"],[this.TUV_LOC,"a_tuv"]])),this.gl.useProgram(this.renderProgram),this.renderMvpMatLoc=this.gl.getUniformLocation(this.renderProgram,"u_mvpMat"),this.renderTextureAtlasLoc=this.gl.getUniformLocation(this.renderProgram,"u_textureAtlas"),this.renderLightDepthArrLoc=this.gl.getUniformLocation(this.renderProgram,"u_lightDepthArr"),this.renderLightDataArrLoc=this.gl.getUniformLocation(this.renderProgram,"u_lightDataArr"),this.renderLightIndexesLoc=this.gl.getUniformLocation(this.renderProgram,"u_lightIndexes"),this.gl.uniform1i(this.renderTextureAtlasLoc,0),this.gl.uniform1i(this.renderLightDepthArrLoc,1),this.gl.uniform1i(this.renderLightDataArrLoc,2),this.gl.uniform1i(this.renderLightIndexesLoc,3),this.shadowProgram=ct(this.gl,[Y(this.gl,this.gl.VERTEX_SHADER,Lt),Y(this.gl,this.gl.FRAGMENT_SHADER,Ct)],new Map([[this.POSITION_LOC,"a_position"]])),this.gl.useProgram(this.shadowProgram),this.shadowMvpMatLoc=this.gl.getUniformLocation(this.shadowProgram,"u_mvpMat");{this.freeLightIndexes=[];for(let h=0;h<J;h++)this.freeLightIndexes.push(h);this.lightDataTexArr=e.createTexture(),e.bindTexture(e.TEXTURE_2D_ARRAY,this.lightDataTexArr),e.texImage3D(e.TEXTURE_2D_ARRAY,0,e.RGBA32F,5,1,J,0,e.RGBA,e.FLOAT,null),e.texParameteri(e.TEXTURE_2D_ARRAY,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D_ARRAY,e.TEXTURE_MIN_FILTER,e.NEAREST),this.shadowTexArr=e.createTexture(),e.bindTexture(e.TEXTURE_2D_ARRAY,this.shadowTexArr),e.texImage3D(e.TEXTURE_2D_ARRAY,0,e.DEPTH_COMPONENT16,Z,Z,J,0,e.DEPTH_COMPONENT,e.UNSIGNED_SHORT,null),e.texParameteri(e.TEXTURE_2D_ARRAY,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D_ARRAY,e.TEXTURE_MIN_FILTER,e.NEAREST),this.shadowFbs=[];for(let h=0;h<J;h++){const n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTextureLayer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,this.shadowTexArr,0,h),this.shadowFbs.push(n)}}this.updateCameraLoc()}}function R(i,s,t){return Math.floor(i)*b*A+Math.floor(s)*A+Math.floor(t)}function Mt(i,s){const t=[i[0]*L,i[1]*b,i[2]*A],e=new Uint16Array(L*b*A),o=20;for(let a=0;a<L;a++)for(let h=0;h<b;h++)for(let n=0;n<A;n++){const r=R(a,h,n),l=a+t[0],c=h+t[1],u=n+t[2],p=s(l/o,c/o,u/o),d=s(l/o,(c-1)/o,u/o);p>.5?d>.5?e[r]=3:e[r]=1:e[r]=0}return e[0]=5,e}function D(i,s){return!(i.textures===void 0||!i.transparent&&!s.transparent||i==s)}function St(i,s,t,e,o,a,h,n,r){const l=[],c=[],u=[];for(let p=0;p<L;p++)for(let d=0;d<b;d++)for(let g=0;g<A;g++){const E=t[R(p,d,g)],f=[i[0]+p,i[1]+d,i[2]+g],_=s.defs[E];if(_.textures===void 0)continue;const x=_.transparent?u:c;if(p===0?D(_,s.defs[e[R(L-1,d,g)]]):D(_,s.defs[t[R(p-1,d,g)]])){const m={bi:E,cubeLoc:f,face:w.LEFT};x.push(m),_.light&&l.push(m)}if(p===L-1?D(_,s.defs[o[R(0,d,g)]]):D(_,s.defs[t[R(p+1,d,g)]])){const m={bi:E,cubeLoc:f,face:w.RIGHT};x.push(m),_.light&&l.push(m)}if(d===0?D(_,s.defs[a[R(p,b-1,g)]]):D(_,s.defs[t[R(p,d-1,g)]])){const m={bi:E,cubeLoc:f,face:w.UP};x.push(m),_.light&&l.push(m)}if(d===b-1?D(_,s.defs[h[R(p,0,g)]]):D(_,s.defs[t[R(p,d+1,g)]])){const m={bi:E,cubeLoc:f,face:w.DOWN};x.push(m),_.light&&l.push(m)}if(g===0?D(_,s.defs[n[R(p,d,A-1)]]):D(_,s.defs[t[R(p,d,g-1)]])){const m={bi:E,cubeLoc:f,face:w.BACK};x.push(m),_.light&&l.push(m)}if(g===A-1?D(_,s.defs[r[R(p,d,0)]]):D(_,s.defs[t[R(p,d,g+1)]])){const m={bi:E,cubeLoc:f,face:w.FRONT};x.push(m),_.light&&l.push(m)}}return{solid:c,transparent:u,lights:l}}function st(i){const s=new Float32Array(i.length*6*9);let t=0;for(const{bi:e,face:o,cubeLoc:[a,h,n]}of i){const r=[a+0,h+0,n+0],l=[a+1,h+0,n+0],c=[a+0,h+0,n+1],u=[a+1,h+0,n+1],p=[a+0,h+1,n+0],d=[a+1,h+1,n+0],g=[a+0,h+1,n+1],E=[a+1,h+1,n+1],f=e*6+o,_=[-1,0,0],x=[1,0,0],m=[0,-1,0],v=[0,1,0],C=[0,0,-1],I=[0,0,1];switch(o){case w.LEFT:{s.set(r,t),t+=3,s.set(_,t),t+=3,s.set([1,0,f],t),t+=3,s.set(c,t),t+=3,s.set(_,t),t+=3,s.set([0,0,f],t),t+=3,s.set(p,t),t+=3,s.set(_,t),t+=3,s.set([1,1,f],t),t+=3,s.set(c,t),t+=3,s.set(_,t),t+=3,s.set([0,0,f],t),t+=3,s.set(g,t),t+=3,s.set(_,t),t+=3,s.set([0,1,f],t),t+=3,s.set(p,t),t+=3,s.set(_,t),t+=3,s.set([1,1,f],t),t+=3;break}case w.RIGHT:{s.set(l,t),t+=3,s.set(x,t),t+=3,s.set([0,0,f],t),t+=3,s.set(d,t),t+=3,s.set(x,t),t+=3,s.set([0,1,f],t),t+=3,s.set(u,t),t+=3,s.set(x,t),t+=3,s.set([1,0,f],t),t+=3,s.set(u,t),t+=3,s.set(x,t),t+=3,s.set([1,0,f],t),t+=3,s.set(d,t),t+=3,s.set(x,t),t+=3,s.set([0,1,f],t),t+=3,s.set(E,t),t+=3,s.set(x,t),t+=3,s.set([1,1,f],t),t+=3;break}case w.UP:{s.set(c,t),t+=3,s.set(m,t),t+=3,s.set([1,1,f],t),t+=3,s.set(r,t),t+=3,s.set(m,t),t+=3,s.set([1,0,f],t),t+=3,s.set(l,t),t+=3,s.set(m,t),t+=3,s.set([0,0,f],t),t+=3,s.set(c,t),t+=3,s.set(m,t),t+=3,s.set([1,1,f],t),t+=3,s.set(l,t),t+=3,s.set(m,t),t+=3,s.set([0,0,f],t),t+=3,s.set(u,t),t+=3,s.set(m,t),t+=3,s.set([0,1,f],t),t+=3;break}case w.DOWN:{s.set(p,t),t+=3,s.set(v,t),t+=3,s.set([0,0,f],t),t+=3,s.set(g,t),t+=3,s.set(v,t),t+=3,s.set([0,1,f],t),t+=3,s.set(d,t),t+=3,s.set(v,t),t+=3,s.set([1,0,f],t),t+=3,s.set(d,t),t+=3,s.set(v,t),t+=3,s.set([1,0,f],t),t+=3,s.set(g,t),t+=3,s.set(v,t),t+=3,s.set([0,1,f],t),t+=3,s.set(E,t),t+=3,s.set(v,t),t+=3,s.set([1,1,f],t),t+=3;break}case w.BACK:{s.set(r,t),t+=3,s.set(C,t),t+=3,s.set([0,0,f],t),t+=3,s.set(p,t),t+=3,s.set(C,t),t+=3,s.set([0,1,f],t),t+=3,s.set(l,t),t+=3,s.set(C,t),t+=3,s.set([1,0,f],t),t+=3,s.set(l,t),t+=3,s.set(C,t),t+=3,s.set([1,0,f],t),t+=3,s.set(p,t),t+=3,s.set(C,t),t+=3,s.set([0,1,f],t),t+=3,s.set(d,t),t+=3,s.set(C,t),t+=3,s.set([1,1,f],t),t+=3;break}case w.FRONT:{s.set(g,t),t+=3,s.set(I,t),t+=3,s.set([1,1,f],t),t+=3,s.set(c,t),t+=3,s.set(I,t),t+=3,s.set([1,0,f],t),t+=3,s.set(u,t),t+=3,s.set(I,t),t+=3,s.set([0,0,f],t),t+=3,s.set(g,t),t+=3,s.set(I,t),t+=3,s.set([1,1,f],t),t+=3,s.set(u,t),t+=3,s.set(I,t),t+=3,s.set([0,0,f],t),t+=3,s.set(E,t),t+=3,s.set(I,t),t+=3,s.set([0,1,f],t),t+=3;break}}}return s}class Nt{constructor(s,t,e,o){const a=tt(e,0),h=tt(o,0),n=tt(W(e,o),0),r=rt(e,t),l=F(B(r,h)),c=rt(l,s),u=$(c,r);this.right=F(B(u,h)),this.up=F(B(u,a)),this.front=F(B(u,n))}}class Ut{constructor(s,t,e){this.getPos=()=>X(this.pos),this.setPos=o=>this.pos=X(o),this.getDir=()=>X(this.dir),this.setDir=o=>this.dir=X(o),this.getMvp=o=>{const a=q(90),h=this.canvas.width/this.canvas.height,n=dt(a,h,.1,100),r=pt(this.pos,T(this.pos,this.dir),o);return $(n,r)},this.pos=s,this.dir=t,this.canvas=e}}class Q{}function Pt(i){function s(e){return e.toString(16).padStart(2,"0")}const t=new Uint8Array(i/2);return window.crypto.getRandomValues(t),Array.from(t,s).join("")}class Ot{constructor(s,t,e,o,a){this.update=()=>{for(const h of this.components)h.applySystem(this)},this.components=s,this.worldup=t,this.worldright=e,this.pos=o===void 0?[0,0,0]:o,this.dir=a===void 0?[1,0,0]:a}}class Gt extends Q{constructor(s,t,e){super(),this.pitch=0,this.yaw=0,this.controlsEnabled=!1,this.fast=!1,this.fly=!0,this.keys=new Set,this.leftMouseDown=!1,this.rightMouseDown=!1,this.applySystem=o=>{const a=new Nt(this.pitch,this.yaw,o.worldup,o.worldright);if(o.dir=y(a.front,-1),this.controlsEnabled){const h=K(W(a.right,o.worldup));let n=this.fast?.1:.04;this.fly?(this.keys.has("KeyW")&&this.physics.go(y(h,n)),this.keys.has("KeyS")&&this.physics.go(y(h,-n)),this.keys.has("KeyA")&&this.physics.go(y(a.right,n)),this.keys.has("KeyD")&&this.physics.go(y(a.right,-n)),this.keys.has("ShiftLeft")&&this.physics.go(y(o.worldup,-n)),this.keys.has("Space")&&this.physics.go(y(o.worldup,n))):(this.keys.has("KeyW")&&this.physics.go(y(h,n)),this.keys.has("KeyS")&&this.physics.go(y(h,-n)),this.keys.has("KeyA")&&this.physics.go(y(a.right,n)),this.keys.has("KeyD")&&this.physics.go(y(a.right,-n)),this.keys.has("Space")&&this.physics.jump()),this.keys.has("Digit1")&&(this.blockInteraction.placeID=1),this.keys.has("Digit2")&&(this.blockInteraction.placeID=2),this.keys.has("Digit3")&&(this.blockInteraction.placeID=3),this.keys.has("Digit4")&&(this.blockInteraction.placeID=4),this.keys.has("Digit5")&&(this.blockInteraction.placeID=5),this.leftMouseDown?this.blockInteraction.breakSelectedBlock():this.rightMouseDown&&this.blockInteraction.placeSelectedBlock()}},this.physics=t,this.blockInteraction=e,this.grabControlElement=s,window.addEventListener("keypress",o=>{o.key==="f"&&(this.fast=!this.fast),o.key==="m"&&(this.fly?(this.fly=!1,this.physics.enablePhysics()):(this.fly=!0,this.physics.disablePhysics()))}),window.addEventListener("keydown",o=>this.keys.add(o.code)),window.addEventListener("keyup",o=>this.keys.delete(o.code)),this.grabControlElement.addEventListener("click",o=>{this.grabControlElement.requestPointerLock()}),document.addEventListener("pointerlockchange",o=>{this.controlsEnabled=document.pointerLockElement===this.grabControlElement}),window.addEventListener("mousemove",o=>{if(!this.controlsEnabled)return;const a=.0015;this.yaw-=o.movementX*a,this.pitch+=o.movementY*a,this.pitch=mt(this.pitch,q(-89.9),q(89.9))}),window.addEventListener("mousedown",o=>{o.button===0?this.leftMouseDown=!0:o.button===2&&(this.rightMouseDown=!0)}),window.addEventListener("mouseup",o=>{o.button===0?this.leftMouseDown=!1:o.button===2&&(this.rightMouseDown=!1)})}}class Xt extends Q{constructor(s){super(),this.applySystem=t=>{this.camera.setDir(t.dir),this.camera.setPos(t.pos)},this.camera=s}}function S(i,s){return i.minX<=s.maxX&&i.maxX>=s.minX&&i.minY<=s.maxY&&i.maxY>=s.minY&&i.minZ<=s.maxZ&&i.maxZ>=s.minZ}class Ft extends Q{constructor(s){super(),this.upVel=0,this.wantGo=[0,0,0],this.wantJump=!1,this.x_rad=.3,this.z_rad=.3,this.p_y_rad=1.5,this.n_y_rad=.3,this.side_depth=.1,this.head_depth=.1,this.foot_depth=.6,this.physicsEnabled=!1,this.enablePhysics=()=>this.physicsEnabled=!0,this.disablePhysics=()=>{this.physicsEnabled=!1,this.upVel=0},this.getPhysicsEnabled=()=>this.physicsEnabled,this.go=t=>{this.wantGo=T(this.wantGo,t)},this.jump=()=>{this.wantJump=!0},this.calculatePlayerIntersection=t=>{let e={minX:t[0]-this.x_rad,maxX:t[0]-this.x_rad+this.side_depth,minY:t[1]-this.n_y_rad+this.head_depth,maxY:t[1]+this.p_y_rad-this.foot_depth,minZ:t[2]-this.z_rad,maxZ:t[2]+this.z_rad},o={minX:t[0]+this.x_rad-this.side_depth,maxX:t[0]+this.x_rad,minY:t[1]-this.n_y_rad+this.head_depth,maxY:t[1]+this.p_y_rad-this.foot_depth,minZ:t[2]-this.z_rad,maxZ:t[2]+this.z_rad},a={minX:t[0]-this.x_rad,maxX:t[0]+this.x_rad,minY:t[1]-this.n_y_rad+this.head_depth,maxY:t[1]+this.p_y_rad-this.foot_depth,minZ:t[2]-this.z_rad,maxZ:t[2]-this.z_rad+this.side_depth},h={minX:t[0]-this.x_rad,maxX:t[0]+this.x_rad,minY:t[1]-this.n_y_rad+this.head_depth,maxY:t[1]+this.p_y_rad-this.foot_depth,minZ:t[2]+this.z_rad-this.side_depth,maxZ:t[2]+this.z_rad},n={minX:t[0]-this.x_rad,maxX:t[0]+this.x_rad,minY:t[1]-this.n_y_rad,maxY:t[1]-this.n_y_rad+this.head_depth,minZ:t[2]-this.z_rad,maxZ:t[2]+this.z_rad},r={minX:t[0]-this.x_rad,maxX:t[0]+this.x_rad,minY:t[1]+this.p_y_rad-this.foot_depth,maxY:t[1]+this.p_y_rad,minZ:t[2]-this.z_rad,maxZ:t[2]+this.z_rad},l=!1,c=!1,u=!1,p=!1,d=!1,g=!1;for(let E=-2;E<=2;E++)for(let f=-2;f<=2;f++)for(let _=-2;_<=2;_++){const x=T(t,[E,f,_]).map(v=>Math.floor(v)),m=this.world.getBlock(x);if(m!=null&&this.world.blockManager.defs[m].pointable){let v={minX:x[0],maxX:x[0]+1,minY:x[1],maxY:x[1]+1,minZ:x[2],maxZ:x[2]+1};!l&&S(e,v)&&(l=!0),!c&&S(o,v)&&(c=!0),!u&&S(n,v)&&(u=!0),!p&&S(r,v)&&(p=!0),!d&&S(a,v)&&(d=!0),!g&&S(h,v)&&(g=!0)}}return{left:l,right:c,up:u,down:p,back:d,front:g}},this.applySystem=t=>{if(!this.physicsEnabled){t.pos=T(t.pos,this.wantGo),this.wantGo=[0,0,0];return}this.upVel-=.001,this.upVel=mt(this.upVel,-.1,.1),this.wantGo=T(this.wantGo,y(t.worldup,this.upVel));let e=T(t.pos,this.wantGo);const o=this.calculatePlayerIntersection(e);this.wantJump&&o.down&&(this.upVel=.05),this.wantJump=!1,o.left&&(this.wantGo[0]=Math.max(this.wantGo[0],0)),o.right&&(this.wantGo[0]=Math.min(this.wantGo[0],0)),o.up&&(this.wantGo[1]=Math.max(this.wantGo[1],0),this.upVel=Math.min(this.upVel,0)),o.down&&(this.wantGo[1]=Math.min(this.wantGo[1],0),this.upVel=Math.max(this.upVel,0)),o.back&&(this.wantGo[2]=Math.max(this.wantGo[2],0)),o.front&&(this.wantGo[2]=Math.min(this.wantGo[2],0)),t.pos=T(t.pos,this.wantGo),this.wantGo=[0,0,0]},this.world=s}}class Bt extends Q{constructor(s,t){super(),this.placeID=2,this.ray=null,this.breakRequests=new Map,this.placeRequests=new Map,this.breakSelectedBlock=()=>{if(this.ray){const e=JSON.stringify(this.ray.coords),o=this.breakRequests.get(e);this.breakRequests.set(e,o===void 0?0:o+1)}},this.placeSelectedBlock=()=>{if(this.ray){const e=JSON.stringify(T(this.ray.coords,_t(this.ray.face))),o=this.placeRequests.get(e);this.placeRequests.set(e,o===void 0?0:o+1)}},this.applySystem=e=>{for(const[o,a]of this.breakRequests)a>30&&(this.world.setBlock(JSON.parse(o),0),this.breakRequests.delete(o));for(const[o,a]of this.placeRequests)a>20&&(this.world.setBlock(JSON.parse(o),this.placeID),this.placeRequests.delete(o));this.ray=this.world.castRay(this.camera.getPos(),this.camera.getDir(),100),this.ray?this.world.addHighlight(this.uniqueId,this.ray):this.world.removeHighlight(this.uniqueId)},this.uniqueId=Pt(32),this.camera=s,this.world=t}}const gt=[0,-1,0],Yt=[-1,0,0];class Ht{constructor(s,t){this.resizeCanvas=()=>{this.canvas.width=window.innerWidth/2,this.canvas.height=window.innerHeight/2},this.start=()=>this.animationLoop(),this.animationLoop=()=>{for(const h of this.entityList)h.update();this.world.update(this.camera.getPos()),this.world.render(this.camera.getMvp(gt)),this.requestID=window.requestAnimationFrame(this.animationLoop)},this.canvas=s,this.blockManager=t,this.camera=new Ut([0,0,0],[0,0,1],this.canvas),this.gl=s.getContext("webgl2"),this.world=new It(42,this.camera.getPos(),this.gl,t,this.camera);const e=new Ft(this.world),o=new Bt(this.camera,this.world),a=new Ot([new Gt(this.canvas,e,o),new Xt(this.camera),e,o],gt,Yt);this.entityList=[a],this.resizeCanvas(),window.addEventListener("resize",this.resizeCanvas)}}async function N(i){return new Promise((s,t)=>{const e=document.getElementById(i);e.onerror=t,e.onload=()=>s(e),e.complete&&s(e)})}async function U(i){return await Promise.all([N(`${i}-left`),N(`${i}-right`),N(`${i}-up`),N(`${i}-down`),N(`${i}-front`),N(`${i}-back`)])}async function zt(){const i=new Tt(16,[{name:"air",pointable:!1,light:!1,transparent:!0},{name:"grass",pointable:!0,light:!1,transparent:!1,textures:await U("grass")},{name:"soil",pointable:!0,light:!1,transparent:!1,textures:await U("soil")},{name:"stone",pointable:!0,light:!1,transparent:!1,textures:await U("stone")},{name:"glass",pointable:!0,light:!1,transparent:!0,textures:await U("glass")},{name:"lamp",pointable:!0,light:!0,transparent:!1,textures:await U("lamp")},{name:"selector",pointable:!0,light:!1,transparent:!1,textures:await U("selector")}]),s=document.getElementById("canvas");new Ht(s,i).start()}zt();
