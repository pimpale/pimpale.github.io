import"./style.7f2dd081.js";import{j as e,s as oe,a as b,b as t,B as se,M as x,S as H,O as le,c as U,W as _,A as V,e as S,d as X,f as Y,L as F,g as C,D as he,h as de,i as $,P as ce,k as z,V as k,l as ue,m as Z,R as me,F as J,n as R,o as c,p as pe,q as ge}from"./vendor.0f15714e.js";import{A as we}from"./ArticleLayout.496e7980.js";import{S as D}from"./Section.2ec38091.js";import{a as N,I,g as L,S as j}from"./ImageDataDisplay.0bbc7509.js";function G(s){return e("a",{className:s.className,id:s.className,href:s.href,children:s.href})}async function fe(s){return await(await fetch(`${oe()}/${s}`)).text()}function K(s,n){return(s%n+n)%n}function Q(s,n,r){return Math.max(Math.min(s,r),n)}async function ye(s){const r=await(await fetch(s)).blob(),i=await createImageBitmap(r),a=document.createElement("canvas");a.width=i.width,a.height=i.height;const l=a.getContext("2d");return l.drawImage(i,0,0),l.getImageData(0,0,i.width,i.height)}function P(s,n,r){N(r>0,"radius must be positive");let i=new ImageData(s.height+r*2,s.width+r*2);switch(n){case"FIXED":{for(let a=0;a<i.width;a++)for(let l=0;l<i.height;l++){const o=Math.max(Math.min(l-r,s.width-1),0),h=(Math.max(Math.min(a-r,s.height-1),0)*s.width+o)*4,d=(a*i.width+l)*4;i.data[d+0]=s.data[h+0],i.data[d+1]=s.data[h+1],i.data[d+2]=s.data[h+2],i.data[d+3]=s.data[h+3]}break}case"PERIODIC":{for(let a=0;a<i.width;a++)for(let l=0;l<i.height;l++){const o=K(l-r,s.width),h=(K(a-r,s.height)*s.width+o)*4,d=(a*i.width+l)*4;i.data[d+0]=s.data[h+0],i.data[d+1]=s.data[h+1],i.data[d+2]=s.data[h+2],i.data[d+3]=s.data[h+3]}break}case"MIRROR":{let a=function(l,o){return l<0?Math.min(Math.max(-l,0),o):l>=o?Math.min(Math.max(2*o-l,0),o):l};for(let l=0;l<i.width;l++)for(let o=0;o<i.height;o++){const u=a(o-r,s.width-1),d=(a(l-r,s.height-1)*s.width+u)*4,m=(l*i.width+o)*4;i.data[m+0]=s.data[d+0],i.data[m+1]=s.data[d+1],i.data[m+2]=s.data[d+2],i.data[m+3]=s.data[d+3]}break}}return i}function q(s,n){N(n>0,"radius must be positive");const r=s.width,i=s.height,a=r-n*2,l=i-n*2;N(a>0&&l>0,"radius is too large");let o=new ImageData(a,l),u=new Uint32Array(r*i),h=new Uint32Array(r*i),d=new Uint32Array(r*i),m=new Uint32Array(r*i);for(let p=0;p<i;p++)for(let w=1;w<r;w++){const f=(i*p+w)*4,g=i*p+w;u[g]=s.data[f+0]+u[g-1],h[g]=s.data[f+1]+h[g-1],d[g]=s.data[f+2]+d[g-1],m[g]=s.data[f+3]+m[g-1]}for(let p=0;p<r;p++)for(let w=1;w<i;w++){const f=i*w+p,g=i*(w-1)+p;u[f]+=u[g],h[f]+=h[g],d[f]+=d[g],m[f]+=m[g]}const y=Math.pow(n*2,2);for(let p=0;p<l;p++)for(let w=0;w<a;w++){const f=w+n,g=p+n,M=f-n+i*(g-n),A=f-n+i*(g+n),E=f+n+i*(g-n),O=f+n+i*(g+n),ie=u[O]-(u[A]+u[E]-u[M]),re=h[O]-(h[A]+h[E]-h[M]),ae=d[O]-(d[A]+d[E]-d[M]),ne=m[O]-(m[A]+m[E]-m[M]),W=(w+p*l)*4;o.data[W+0]=ie/y,o.data[W+1]=re/y,o.data[W+2]=ae/y,o.data[W+3]=ne/y}return o}function be(s,n,r,i,a){N(Number.isInteger(n),"srcx is not integer"),N(Number.isInteger(r),"srcy is not integer"),N(Number.isInteger(i),"xsize is not integer"),N(Number.isInteger(a),"ysize is not integer");let l=new ImageData(i,a);for(let o=0;o<a;o++)for(let u=0;u<i;u++){const h=(n+u+(r+o)*s.height)*4,d=(u+o*a)*4;l.data[d+0]=s.data[h+0],l.data[d+1]=s.data[h+1],l.data[d+2]=s.data[h+2],l.data[d+3]=s.data[h+3]}return l}class ee extends b.Component{constructor(n){super(n);this.displayCanvas=b.createRef(),this.closeupCanvas=b.createRef(),this.mloc=null,this.getMousePos=r=>{const i=this.displayCanvas.current,a=i.getBoundingClientRect(),l=i.width/a.width,o=i.height/a.height;return{x:(r.clientX-a.left)*l,y:(r.clientY-a.top)*o}},this.handleMouseOver=r=>{this.mloc=this.getMousePos(r),this.paint()},this.handleMouseLeave=()=>{this.mloc=null,this.paint()},this.paint=this.paint.bind(this)}componentDidMount(){this.displayCanvas.current.addEventListener("mousemove",this.handleMouseOver),this.displayCanvas.current.addEventListener("mouseleave",this.handleMouseLeave),this.paint()}componentDidUpdate(){this.paint()}paint(){const r=this.displayCanvas.current.getContext("2d"),i=this.closeupCanvas.current;if(r!=null)if(r.putImageData(this.props.data,0,0),this.mloc!=null){const a=this.props.zoomRadius,l=Math.floor(Q(this.mloc.x-a/2,a,this.props.data.width-a)),o=Math.floor(Q(this.mloc.y-a/2,a,this.props.data.height-a)),u=i.getContext("2d");if(u!=null){u.imageSmoothingEnabled=!1;const h=be(this.props.data,l,o,this.props.zoomRadius,this.props.zoomRadius);u.putImageData(h,0,0)}r.fillStyle="#FF0000",r.fillRect(l,o,this.props.zoomRadius,this.props.zoomRadius)}else{const a=i.getContext("2d");a!=null&&a.clearRect(0,0,this.props.zoomRadius,this.props.zoomRadius)}}render(){const{width:n,height:r}=this.props.data;return e("div",{style:this.props.style,className:this.props.className,children:t("div",{className:"d-flex align-items-center justify-content-center",children:[e("canvas",{className:"border border-dark mx-2",ref:this.displayCanvas,width:n,height:r}),e("canvas",{className:"border border-dark mx-2",style:{height:this.props.displayHeight/2,width:this.props.displayHeight/2},ref:this.closeupCanvas,width:this.props.zoomRadius,height:this.props.zoomRadius})]})})}}var ve="/assets/wrapping_noise3_ts.81c412b0.txt",xe="/assets/Mug_and_Torus_morph.a0436a0d.gif",ke="/assets/ColorWheel.306e0194.png",Re="/assets/TorusLabeled.3d7a30a3.png",Ne="/assets/SimplyConnectedRegionExample1.91d0defe.png",Ie="/assets/SimplyConnectedRegionExample2.4fdc8cfd.png",Me="/assets/SimplyConnectedRegionExample3.f5dce294.png",Se="/assets/VerticallySimpleRegionExample1.5762e05d.png",Ce="/assets/VerticallySimpleRegionExample2.191f2685.png";const T=new se(1,1,1,5,5,5),Te=[new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,color:4556168}),new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,color:14431557}),new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,color:10000154}),new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,color:11625094}),new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,color:14129441}),new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,color:15457202})];class De extends b.Component{constructor(){super(...arguments);this.mount=b.createRef(),this.range=b.createRef(),this.sceneSetup=()=>{const n=this.mount.current.clientWidth,r=this.mount.current.clientHeight;this.scene=new H,this.camera=new le(-1.5,1.5,1.5,-1.5),this.camera.position.z=10,this.controls=new U(this.camera,this.mount.current),this.controls.noPan=!0,this.controls.noZoom=!0,this.renderer=new _({alpha:!0}),this.renderer.setSize(n,r),this.mount.current.appendChild(this.renderer.domElement)},this.addCustomSceneObjects=()=>{const n=new V(16777215);this.scene.add(n)},this.handleCircularityChange=()=>{const n=this.range.current.valueAsNumber,r=new Float32Array(T.attributes.position.count*3);for(let h=0;h<T.attributes.position.count;h++){const d=T.attributes.position.getX(h),m=T.attributes.position.getY(h),y=T.attributes.position.getZ(h),p=Math.hypot(d,m,y),w=d/p,f=m/p,g=y/p;r[h*3+0]=d+(w-d)*n,r[h*3+1]=m+(f-m)*n,r[h*3+2]=y+(g-y)*n}let i=T.clone();i.setAttribute("position",new S(r,3)),this.scene.remove(this.mesh);const a=new X(i,Te);this.scene.add(a),this.mesh=a;let l=new Y(this.mesh.geometry),o=new F({color:1908769}),u=new C(l,o);a.add(u)},this.startAnimationLoop=()=>{this.controls.update(),this.renderer.render(this.scene,this.camera),this.requestID=window.requestAnimationFrame(this.startAnimationLoop)},this.handleWindowResize=()=>{const n=this.mount.current.clientWidth,r=this.mount.current.clientHeight;this.controls.handleResize(),this.renderer.setSize(n,r)}}componentDidMount(){this.sceneSetup(),this.addCustomSceneObjects(),this.handleCircularityChange(),this.startAnimationLoop(),window.addEventListener("resize",this.handleWindowResize),this.range.current.addEventListener("input",this.handleCircularityChange)}componentWillUnmount(){this.range.current.removeEventListener("input",this.handleCircularityChange),window.removeEventListener("resize",this.handleWindowResize),window.cancelAnimationFrame(this.requestID),this.controls.dispose()}render(){return t("div",{style:this.props.style,className:this.props.className,children:[e("div",{ref:this.mount,className:"ratio ratio-1x1 border border-dark"}),t("div",{className:"mx-auto d-block flex-grow-1 ",children:[e("label",{className:"form-label",children:"Circularness"}),e("input",{type:"range",className:"form-range",min:"0",max:"1",step:"0.05",defaultValue:"0",ref:this.range})]})]})}}class B extends b.Component{constructor(){super(...arguments);this.mount=b.createRef(),this.torusnessRange=b.createRef(),this.majorRange=b.createRef(),this.minorRange=b.createRef(),this.lerpRange=b.createRef(),this.sceneSetup=()=>{const n=this.mount.current.clientWidth,r=this.mount.current.clientHeight;if(this.props.texture){const l=new he(this.props.texture.data,this.props.texture.width,this.props.texture.height,de);l.needsUpdate=!0,this.planeMaterial=new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,map:l,side:$})}else this.planeMaterial=new x({polygonOffset:!0,polygonOffsetFactor:1,polygonOffsetUnits:1,color:9355388,side:$});const i=this.props.detailLevel,a=this.props.detailLevel;this.planeGeometry=new ce(1,1,i,a),this.wireframeMaterial=new F({color:1908769}),this.xEdgeMaterial=new F({color:14431557}),this.yEdgeMaterial=new F({color:6689010}),this.leftEdgeGeometry=new z().setFromPoints(new Array(i).fill(null).flatMap((l,o)=>[new k(-.5,o/i-.5,0),new k(-.5,(o+1)/i-.5,0)])),this.rightEdgeGeometry=new z().setFromPoints(new Array(i).fill(null).flatMap((l,o)=>[new k(.5,o/i-.5,0),new k(.5,(o+1)/i-.5,0)])),this.topEdgeGeometry=new z().setFromPoints(new Array(a).fill(null).flatMap((l,o)=>[new k(o/a-.5,.5,0),new k((o+1)/a-.5,.5,0)])),this.bottomEdgeGeometry=new z().setFromPoints(new Array(a).fill(null).flatMap((l,o)=>[new k(o/a-.5,-.5,0),new k((o+1)/a-.5,-.5,0)])),this.scene=new H,this.camera=new ue(45,1,.1,100),this.camera.position.z=2,this.controls=new U(this.camera,this.mount.current),this.controls.noPan=!0,this.controls.noZoom=!0,this.renderer=new _({alpha:!0}),this.renderer.setSize(n,r),this.mount.current.appendChild(this.renderer.domElement)},this.addCustomSceneObjects=()=>{const n=new V(16777215);this.scene.add(n)},this.interpolate=(n,r,i,a)=>{const l=new Float32Array(n.length),o=.5,u=o/this.props.aspectRatio;for(let h=0;h<n.length/3;h++){const d=n[h*3+0],m=n[h*3+1],y=n[h*3+2],p=(d*i+.5)*2*Math.PI,w=m*r*2*Math.PI,f=(o+u*Math.cos(p))*Math.cos(w),g=(o+u*Math.cos(p))*Math.sin(w),M=u*Math.sin(p);l[h*3+0]=d+(f-d)*a,l[h*3+1]=m+(g-m)*a,l[h*3+2]=y+(M-y)*a}return l},this.handleTorusChange=()=>{const n=this.torusnessRange.current.valueAsNumber;this.majorRange.current.valueAsNumber=n,this.minorRange.current.valueAsNumber=n,this.lerpRange.current.valueAsNumber=Math.min(n*1.5,1),this.handleCircularityChange()},this.handleCircularityChange=()=>{const n=this.majorRange.current.valueAsNumber,r=this.minorRange.current.valueAsNumber,i=this.lerpRange.current.valueAsNumber;this.scene.remove(this.mesh);const a=this.interpolate(this.planeGeometry.attributes.position.array,n,r,i);let l=this.planeGeometry.clone();l.setAttribute("position",new S(a,3));const o=new X(l,this.planeMaterial);this.props.wireframe&&o.add(new C(new Y(o.geometry),this.wireframeMaterial));let u=this.leftEdgeGeometry.clone();u.setAttribute("position",new S(this.interpolate(this.leftEdgeGeometry.attributes.position.array,n,r,i),3)),o.add(new C(u,this.xEdgeMaterial));let h=this.rightEdgeGeometry.clone();h.setAttribute("position",new S(this.interpolate(this.rightEdgeGeometry.attributes.position.array,n,r,i),3)),o.add(new C(h,this.xEdgeMaterial));let d=this.topEdgeGeometry.clone();d.setAttribute("position",new S(this.interpolate(this.topEdgeGeometry.attributes.position.array,n,r,i),3)),o.add(new C(d,this.yEdgeMaterial));let m=this.bottomEdgeGeometry.clone();m.setAttribute("position",new S(this.interpolate(this.bottomEdgeGeometry.attributes.position.array,n,r,i),3)),o.add(new C(m,this.yEdgeMaterial)),this.scene.add(o),this.mesh=o},this.startAnimationLoop=()=>{this.controls.update(),this.renderer.render(this.scene,this.camera),this.requestID=window.requestAnimationFrame(this.startAnimationLoop)},this.handleWindowResize=()=>{const n=this.mount.current.clientWidth,r=this.mount.current.clientHeight;this.controls.handleResize(),this.renderer.setSize(n,r)}}componentDidMount(){this.sceneSetup(),this.addCustomSceneObjects(),this.handleCircularityChange(),this.startAnimationLoop(),window.addEventListener("resize",this.handleWindowResize),this.torusnessRange.current.addEventListener("input",this.handleTorusChange),this.majorRange.current.addEventListener("input",this.handleCircularityChange),this.minorRange.current.addEventListener("input",this.handleCircularityChange),this.lerpRange.current.addEventListener("input",this.handleCircularityChange)}componentWillUnmount(){this.torusnessRange.current.removeEventListener("input",this.handleTorusChange),this.majorRange.current.removeEventListener("input",this.handleCircularityChange),this.minorRange.current.removeEventListener("input",this.handleCircularityChange),this.lerpRange.current.removeEventListener("input",this.handleCircularityChange),window.removeEventListener("resize",this.handleWindowResize),window.cancelAnimationFrame(this.requestID),this.controls.dispose()}render(){return t("div",{style:this.props.style,className:this.props.className,children:[e("div",{ref:this.mount,className:"ratio ratio-1x1 border border-dark mb-3"}),t("div",{className:"mx-auto d-block flex-grow-1 mb-2",children:[e("label",{className:"form-label",children:"Torusness"}),e("input",{type:"range",className:"form-range",min:"0",max:"1",step:"0.05",defaultValue:"0",ref:this.torusnessRange})]}),t("details",{children:[e("summary",{children:"Advanced Torus Controls"}),t("div",{className:"mx-auto d-block flex-grow-1 ",children:[e("label",{className:"form-label",children:"Join Major"}),e("input",{type:"range",className:"form-range",min:"0",max:"1",step:"0.05",defaultValue:"0",ref:this.majorRange})]}),t("div",{className:"mx-auto d-block flex-grow-1 ",children:[e("label",{className:"form-label",children:"Join Minor"}),e("input",{type:"range",className:"form-range",min:"0",max:"1",step:"0.05",defaultValue:"0",ref:this.minorRange})]}),t("div",{className:"mx-auto d-block flex-grow-1 ",children:[e("label",{className:"form-label",children:"Alpha"}),e("input",{type:"range",className:"form-range",min:"0",max:"1",step:"0.05",defaultValue:"0",ref:this.lerpRange})]})]})]})}}const te=Z.makeNoise2D(Date.now()),Ae=Z.makeNoise3D(Date.now()),v=s=>e("div",{className:"card mx-5 mb-4",id:s.id,children:t("div",{className:"card-body",children:[e("h6",{className:"card-title text-decoration-underline",children:s.title}),e("div",{className:"card-text",children:s.children})]})}),Ee=()=>e(we,{children:({Citation:s,CitationBank:n})=>t(J,{children:[t(D,{id:"overview",name:"Overview",children:[e("h4",{children:"Goals"}),e("p",{children:"Our goal in this article will be to procedurally generate and simulate a small game world. There are hundreds of ways to do this, and as we go along, we'll explore some of the different strategies we could have chosen and their tradeoffs."}),e("h4",{children:"Rationale"}),t("p",{children:["Procedural generation is a versatile tactic in game programming. Games that utilize procedural generation can have much larger maps than those with handcrafted levels, since they can generate content on the fly. ( Ex. Minecraft",e(s,{source:"https://en.wikipedia.org/wiki/Minecraft"})," and No Man's Sky ",e(s,{source:"https://en.wikipedia.org/wiki/No_Man%27s_Sky"}),") However, a potential downside is that excessive use of procedural generation makes games feel predictable and repetitive. In order to mitigate this, some games increase the depth of the world by using more elaborate generation systems. Dwarf Fortress, for example, even ",e("a",{href:"https://dwarffortresswiki.org/index.php/DF2014:World_generation",children:"simulates an entire virtual history"}),". In the following sections, we'll discuss some techniques that could be used to procedurally generate content for a hypothetical game."]}),e("h4",{children:"Key Decisions"}),e("p",{children:"In summary, our key techniques are as follows:"}),t("ul",{children:[e("li",{children:"Finite (but large) world"}),e("li",{children:"Square grid as fundamental data structure"}),e("li",{children:"World level procedural generation done at worldgen time, chunk level procedural generation done at runtime."}),e("li",{children:"Donut world (Periodic Boundary Conditions)"}),e("li",{children:"Detailed biome and weather simulations"}),e("li",{children:"Hydraulic Erosion (Fjords and River Valleys)"}),e("li",{children:"Simulating History"})]}),e("p",{children:"To keep things interesting, we'll make our game world unique by putting it on a torus planet. This will have a ton of effects on the terrain, climate, and overall environment."})]}),t(D,{id:"topology",name:"World Topology",children:[e("h4",{children:"Topology"}),t("p",{children:["Our first (and perhaps biggest) major choice is deciding on the world's ",e("strong",{children:"topology"}),"."]}),t(v,{title:"Topology",children:[e("strong",{children:"Topology"})," describes the fundamental geometric properties of an object, especially those properties that don't change as the object is stretched, squished, or otherwise distorted. For example, a coffee mug is topologically equivalent to a donut since the mug, like the donut, has one through hole.",t("figure",{className:"text-center my-3",children:[e("img",{src:xe,className:"border border-dark mx-auto d-block",alt:"A mug morphing into a torus and back"}),t("figcaption",{children:["Source: ",e("a",{href:"https://commons.wikimedia.org/wiki/File:Mug_and_Torus_morph.gif",children:"Wikipedia"})]})]}),"If you're interested, ",e("a",{href:"https://en.wikipedia.org/wiki/Topology",children:"you can read more about topology on Wikipedia"}),"."]}),e("p",{children:"For our purposes, however, we want to know how the world should be shaped:"}),t("ul",{children:[e("li",{children:"Is it 2D or or 3D?"}),e("li",{children:"Infinite or finite?"}),e("li",{children:"Flat or Sphere?"}),e("li",{children:"Boundary Conditions?"})]}),e("p",{children:"We will answer each of these questions in turn."}),e("h4",{children:"3D or 2D?"}),e("p",{children:"In this article, we'll choose a 3D game since it tends to be easier to adapt a 3d algorithm to a 2d world than the other way around. However, it's important to note: just because our game world is 3D doesn't mean we always need to use a 3D data structure when generating the world. If we guarantee that for each point on our world's surface, the elevation is a well defined number, then we can use a 2d graph or grid to represent the heightmap."}),t("p",{children:["However, heightmaps won't work if our terrain isn't ",e("strong",{children:"vertically simple"}),"."]}),t(v,{title:"Vertically Simple Regions",children:[t("p",{children:["In math, a ",e("strong",{children:"region"})," is a ",e("a",{href:"https://en.wikipedia.org/wiki/Connected_space",children:"simply connected"})," area of space."]}),t("div",{className:"row my-3",children:[t("figure",{className:"col text-center",children:[e("img",{alt:"Example of region",className:"d-block mx-auto",style:{width:"15em"},src:Ne}),e("figcaption",{children:"Source: Own Work"}),e("p",{children:"This blob is a region."})]}),t("figure",{className:"col text-center",children:[e("img",{alt:"Example of region",className:"d-block mx-auto",style:{width:"15em"},src:Ie}),e("figcaption",{children:"Source: Own Work"}),e("p",{children:"This example is irregular, but also a region. (All parts are connected.)"})]}),t("figure",{className:"col text-center",children:[e("img",{alt:"Example of a non region",className:"d-block mx-auto",style:{width:"15em"},src:Me}),e("figcaption",{children:"Source: Own Work"}),t("p",{children:["This example is ",e("strong",{children:e("em",{children:"NOT"})})," a region since its broken in two parts. (Not simply connected.)"]})]})]}),t("p",{children:["A ",e("strong",{children:"vertically simple"})," region is a region where a line can be drawn vertically and only cross the region once."]}),t("div",{className:"row my-3",children:[t("figure",{className:"col text-center",children:[e("img",{alt:"Example of region",className:"d-block mx-auto",style:{width:"15em"},src:Se}),e("figcaption",{children:"Source: Own Work"}),e("p",{children:"We can draw a vertical line at every point on this image, and it will only cross the region's boundary once. Therefore, this region is vertically simple."})]}),t("figure",{className:"col text-center",children:[e("img",{alt:"Example of region",className:"d-block mx-auto",style:{width:"15em"},src:Ce}),e("figcaption",{children:"Source: Own Work"}),t("p",{children:["This example is ",e("strong",{children:e("em",{children:"NOT"})})," vertically simple since we can draw a line down the center that crosses the region's boundary twice."]})]})]})]}),e("p",{children:'For example, if we want our world to be primarily cave based, with no real "surface" to speak of, then a given (x, y) coordinate pair may have multiple surfaces at different z levels. The same problem would apply for a floating island map. A possible workaround would be to use a small number of discrete z levels, each of which uses its own seperate heightmap. This approach is less efficient compared to a single heightmap, but since each per unit heightmap is smaller, it may still be feasible.'}),e("h4",{children:"Infinite or Finite?"}),t("p",{children:["If we don't have any complex build time systems, then we can make our world size effectively infinite, and just generate everything at runtime. This is the approach Minecraft takes.",e(s,{source:"https://en.wikipedia.org/wiki/Minecraft"}),"In some ways, this is optimal: The user doesn't have to wait at all for world generation, and we have a lot of flexibility with how large the map should be."]}),e("p",{children:"However, an infinite world bars us from doing deeper simulations that require knowledge of the game map ahead of time. We can't generate realistic rivers, glaciers, or historical simulations in such a world. For this reason, we'll choose a finite, but reasonably large, size."}),e("h4",{children:"Flat or Sphere?"}),e("p",{children:"Spherical worlds are more realistic, so if creating an accurate simulation is important, spheres are the way to go. Spherical geometry is also required if you want to be able to render the planet's surface from space."}),t("p",{children:["However, spherical geometry is incompatible with voxel tiling over the surface. If we tile over the surface of a sphere with a square grid, we will end up with at least a few ",e("strong",{children:"singularities"}),"."]}),t(v,{title:"Singularities",children:[t("p",{children:["The most common use of the word ",e("strong",{children:"singularity"})," is in reference to the center of a black hole, where gravity is infinitely strong. However, a singularity can refer to any point where a mathematical function is undefined or has a undefined derivative."]}),e(De,{className:"mx-auto",style:{width:"20em"}}),e("p",{children:"The demo above shows a simple way to tile a sphere using squares. In the context of using a square grid to title over a sphere, singularties are points where our regular grid breaks down. Notice how each corner square tile will be missing one diagonal neighbor, resulting in angles near it being highly distorted. So in this case singularities appear at the corners of the cube."}),e("p",{children:"In general though, there is no way to tile a sphere using a regular square grid. There will always be tiles with less than the normal number of neighboring tiles."})]}),e("p",{children:"Since dealing with spheres is a needless hassle unless we have a specific use case, we're going to try to use a flat surface without curvature. This will enable us to use a grid when processing the data."}),e("h4",{children:"Boundary Conditions?"}),e("p",{children:`Now that we've settled on a flat finite surface, we have to decide what should go at the edges. However, we need to do more than just decide the content of the edge grid tiles. Many map operations need to access data from neighboring tiles. So, in order to process the edge tiles, we need to gather data from "beyond the edge".`}),t("p",{children:["A ",e("strong",{children:"boundary condition"})," is a constraint on how we treat operations that go over the edges."]}),e("p",{children:"We'll use a box blur in order to demonstrate the impacts of boundary conditions."}),e(v,{title:"Blurring And Boundary Conditions",children:e(R,{promise:ye(ke).then(r=>({img:r,radius:100})),children:({setData:r})=>t(J,{children:[e(R.Pending,{children:e("div",{className:"spinner-border",role:"status"})}),e(R.Fulfilled,{children:({img:i,radius:a})=>{const l=P(i,"FIXED",a),o=P(i,"MIRROR",a),u=P(i,"PERIODIC",a),h=q(l,a),d=q(o,a),m=q(u,a);return t("div",{className:"container",children:[t("div",{className:"mx-auto text-center my-3",style:{width:"20em"},children:[e("p",{children:e("strong",{children:"Source Image"})}),e(I,{style:{width:"15em",height:"15em"},className:"border border-dark mx-auto d-block",data:i}),t("small",{children:["Source: ",e("a",{href:"https://commons.wikimedia.org/wiki/File:Eight-colour-wheel-2D.png",children:"Wikipedia"})]}),t("div",{className:"mx-auto d-block mt-3",children:[e("label",{className:"form-label",children:"Blur Radius"}),e("input",{type:"range",className:"form-range",min:"1",max:"120",defaultValue:"60",onChange:y=>r({radius:y.target.valueAsNumber,img:i})})]})]}),t("div",{className:"row",children:[t("div",{className:"col",children:[e("strong",{children:"Fixed Boundary Condition"}),e("p",{children:"After extension:"}),e(I,{className:"border border-dark",style:{width:"15em",height:"15em"},data:l}),e("p",{children:"Final Result:"}),e(I,{className:"border border-dark",style:{width:"15em",height:"15em"},data:h})]}),t("div",{className:"col",children:[e("strong",{children:"Mirrored Boundary Condition"}),e("p",{children:"After extension:"}),e(I,{className:"border border-dark",style:{width:"15em",height:"15em"},data:o}),e("p",{children:"Final Result:"}),e(I,{className:"border border-dark",style:{width:"15em",height:"15em"},data:d})]}),t("div",{className:"col",children:[e("strong",{children:"Periodic Boundary Condition"}),e("p",{children:"After extension:"}),e(I,{className:"border border-dark",style:{width:"15em",height:"15em"},data:u}),e("p",{children:"Final Result:"}),e(I,{className:"border border-dark",style:{width:"15em",height:"15em"},data:m})]})]})]})}})]})})}),e("p",{children:"Essentially:"}),t("ul",{children:[e("li",{children:"Fixed boundary conditions extend the value that was closest to the edge."}),e("li",{children:"Mirrored boundary conditions make a mirror the data on the side closest."}),e("li",{children:"Periodic boundary conditions take data from the opposite edge of the image."})]}),e("p",{children:"Note how the choice of the boundary condition makes a huge impact on the final blurred image."}),t("p",{children:["All of these boundary conditions are workable for our purposes. We're going to choose a periodic boundary condition though, since it means we don't have to deal with invisible world barriers. This is the same approach taken by a lot of old RPGs, like Final Fantasy.",e(s,{source:"https://tvtropes.org/pmwiki/pmwiki.php/Main/VideoGameGeography"})]}),e("p",{children:"Unlike a spherical world, creating a coordinate system is straightforward on a toroidal world. We can simply index into our rectangular array using a x coordinate and a y coordinate."})]}),t(D,{id:"torusWorld",name:"A Torus World",children:[e("h4",{children:"Topology of Periodic Boundary Conditions"}),e("p",{children:"Periodic boundary conditions imply that the world forms a torus."}),e("p",{children:"If we were to glue together the top and bottom edges of the map, we would get a cylinder. Then, as we glue the east and west ends of the cylinder together, we would get a torus."}),t(v,{title:"Torus Widget",children:[e("p",{children:"Play with this interactive widget to explore how we can join the edges of a rectangle to form a torus."}),e(B,{className:"mx-auto",style:{width:"20em"},aspectRatio:2,detailLevel:10,wireframe:!0})]}),e("h4",{children:"Real World Implications"}),e("p",{children:"It's actually technically possible (although very unlikely) for torus shaped planets to exist in the universe. However, there are a lot of unexpected implications of such a strange layout. For one, the gravity on the planet will vary depending where you are: high near the poles and low near the inner and outer edges. In addition, the torus can cast a shadow on itself, leading to strange day/night patterns and seasons."}),e("p",{children:"If you'd like to learn more, here are a few articles on the topic:"}),e("ul",{children:e("li",{children:e(G,{href:"http://www.aleph.se/andart/archives/2014/02/torusearth.html"})})}),e("p",{children:"In this project, we'll take into account many of the effects of a torus world, like the day/night cycle, and the difference between the inner and outer radiuses. However, we'll also show how these effects work on a nontoroidal surface like a plane or sphere."})]}),t(D,{id:"terrainGeneration",name:"Terrain Generation",children:[e("p",{children:"We'll be using a rectangular grid to represent map data, since it works well with our choice of a torus world."}),t("p",{children:["In order to do so, we need a source of ",e("strong",{children:"coherent noise"}),"."]}),t(v,{title:"Coherent Noise",children:[t("p",{children:["If we try to fill a grid with normal noise, using something like ",e("code",{className:"ms-1 me-1",children:"Math.random()"}),", this is what we would get:"]}),e(ee,{className:"mx-auto mb-3",zoomRadius:5,displayHeight:240,data:L(new j(240,240,Math.random))}),t("p",{children:["Let's use math to describe the signature of ",e("code",{className:"ms-1 me-1",children:"Math.random"}),":"]}),e(c,{block:!0,children:"random: () \\to \\reals"}),e("p",{children:"Essentially, the above function maps from nothing (an empty tuple) to a real number in the range [0, 1). In reality, there's some hidden state seeding the algorithm internally, but it's not accessible from the API."}),e("p",{children:"Importantly, the output value is not correlated to any coordinates. Since every the noise at every point is unrelated to its coordinates, there's no large scale structure. So, this kind of noise isn't suitable for terrain generation."}),e("p",{children:"We need to use an algorithm that's capable of generating noise such that points that are close together spatially have similar values. To do this, we'll need our noise to accept x and y coordinates."}),e("p",{children:"The function signature for our noise might look something like this:"}),e(c,{block:!0,children:"coherentRandom: \\reals^2  \\to \\reals"}),e("p",{children:"It accepts a pair of real numbers, the X and Y coordinates, and spits out a real number representing the value at that region."}),e("p",{children:"This is an example of what coherent noise looks like:"}),e(ee,{className:"mx-auto mb-3",zoomRadius:5,displayHeight:240,data:L(new j(240,240,(r,i)=>te(r/20,i/20)/2+.5))}),e("p",{children:"You can see that every pixel has a neighboring pixel that is similarly colored."}),e("p",{children:"There are several algorithms capable of generating coherent noise:"}),t("ul",{children:[e("li",{children:e("a",{href:"https://en.wikipedia.org/wiki/Perlin_noise",children:"Perlin Noise"})}),e("li",{children:e("a",{href:"https://en.wikipedia.org/wiki/Simplex_noise",children:"Simplex Noise"})}),e("li",{children:e("a",{href:"https://en.wikipedia.org/wiki/OpenSimplex_noise",children:"OpenSimplex Noise"})})]}),e("p",{children:"We'll be using OpenSimplex since it's open source and provides good performance."})]}),e("p",{children:"Now that we've got our coherent noise, it's time to start putting things together."}),"We need to:",t("ul",{children:[e("li",{children:"Make our noise wrap across the boundaries of the rectangle."}),e("li",{children:"Make our noise more realistic."})]}),e("h4",{children:"Wrapping noise"}),e("p",{children:"When we say that we want our noise to wrap around the boundaries of the rectangle, what we mean is that there must be a seamless transition between the left and right edges of the rectangle as well as the top and bottom edges."}),e("p",{children:"Let's look at an example of what might happen if the texture doesn't wrap when we put it on the torus."}),e(v,{title:"Nonwrapping Texture",id:"nonwrapping-textures-demo",children:e(B,{className:"mx-auto",style:{width:"20em"},texture:L(new j(400,400,(r,i)=>te(r/20,i/20)/2+.5)),aspectRatio:2,detailLevel:20,wireframe:!1})}),e("p",{children:"The solution to this problem is actually pretty intuitive. Right now, what we're doing is making a 2D sheet, and sampling 2D noise. The problem is that points that are close together in 3D are far away in 2D, so we get seams. Instead, why don't we start with a blank 2D sheet, roll it up into a torus, and then sample 3D noise? This would mean that regions that are adjacent in 3D space would have similar noise values, even if their 2D coordinate were far away."}),e("p",{children:"Let's give it a try. But first, we have to be able to mathematically describe a torus in terms of two coordinates. We know this is possible, since we were able to convert a rectangle (which can be indexed with x and y coordinates) into a torus."}),t("p",{children:["In general, the term for this kind of thing is ",e("strong",{children:"parameterization"}),"."]}),t(v,{title:"Parametric Functions and Surfaces",children:[t("p",{children:["A ",e("strong",{children:"parametric function"})," is a function that maps from a set of independent input variables called ",e("strong",{children:"parameters"})," to a point in space."]}),t("details",{className:"mb-3 mx-5",children:[e("summary",{children:"Example"}),e("p",{children:"Imagine a ball thrown in the air with an upward velocity of 8 m/s and a horizontal velocity of 7 m/s."}),e("p",{children:"We know that the ball will continue to move sideways at a rate of 7 m/s, so we can say:"}),e(c,{block:!0,children:"x(t) = 7t"}),t("p",{children:["In addition, we know that the ball will accelerate downwards at a rate of 10 m/s",e("sup",{children:"2"})," due to gravity. Using our basic kinematics knowledge that:"]}),e(c,{block:!0,children:String.raw`
            x(t) = \frac {1} {2} at^2 + vt + x
          `}),"We can conclude that:",e(c,{block:!0,children:"y(t) = -5t^2 + 8t"}),e("p",{children:"We can now make a parametric function mapping from time (the parameter) to a location in space. This is a parametric function!"}),e(c,{block:!0,children:String.raw`
            r(t) =
            \begin{bmatrix}
              7t \\
              -5t^2 + 8t
            \end{bmatrix}
          `})]}),t("p",{children:["Parametric functions with 2 parameters are commonly used to describe 3D surfaces. A ",e("strong",{children:"parameterization"})," of a surface is parametric function with the signature:",e(c,{block:!0,children:"r: \\reals^2 \\to \\reals^3"}),"It maps from a 2D parameter space to a 3D surface."]}),e("p",{children:"Khan Academy is a good resource for learning more about parametric functions:"}),t("ul",{children:[e("li",{children:e(G,{href:"https://www.khanacademy.org/math/ap-calculus-bc/bc-advanced-functions-new"})}),e("li",{children:e(G,{href:"https://www.khanacademy.org/math/multivariable-calculus/thinking-about-multivariable-function/ways-to-represent-multivariable-functions/a/parametric-functions-two-parameters"})})]})]}),e("p",{children:"Before we can parameterize our torus, we have to define its properties:"}),t("ul",{children:[t("li",{children:[e("strong",{children:"Major Radius"}),": the distance from the center of the torus to the center of the tube (denoted ",e(c,{children:"R"}),")"]}),t("li",{children:[e("strong",{children:"Minor Radius"}),": the radius of the tube (denoted ",e(c,{children:"r"}),")"]}),t("li",{children:[e("strong",{children:"Aspect Ratio"}),": the ratio of the major radius to the minor radius, ",e(c,{children:String.raw`\frac {R} {r}`})]})]}),t("figure",{className:"text-center my-3",children:[e("img",{src:Re,className:"border border-dark mx-auto d-block",alt:"Torus labeled with minor and major radiuses",style:{width:"30rem"}}),t("figcaption",{children:["Source: ",e("a",{href:"https://commons.wikimedia.org/wiki/File:Torus_cycles.svg",children:"Wikipedia"})]})]}),t("p",{children:["The torus we're dealing with has ",e(c,{children:"R = 2"})," and ",e(c,{children:"r = 1"}),"."]}),t("p",{children:["The parameterization of a torus with major radius ",e(c,{children:"R"})," and minor radius ",e(c,{children:"r"})," is given by the function:",e(c,{block:!0,children:String.raw`
          r(\theta, \phi) =
          \begin{bmatrix}
            (R + r\cos \theta) \cos \phi \\
            (R + r\cos \theta) \sin \phi \\
            r \sin \theta
          \end{bmatrix}
        `}),"We can gain a better intuition for how this function works if we understand what ",e(c,{children:"\\theta"})," and ",e(c,{children:"\\phi"})," really do."]}),t("ul",{children:[t("li",{children:[e(c,{children:"\\theta"})," represents rotation around the tube"]}),t("li",{children:[e(c,{children:"\\phi"})," represents rotation around the center axis"]})]}),t("p",{children:['It may be helpful to scroll up and open the "Advanced Torus Controls" box on the ',e("a",{href:"#nonwrapping-textures-demo",children:"nonwrapping textures demo"}),". Try moving the Alpha slider to the max and then seeing what effect changing the major and minor radiuses have."]}),e("p",{children:"Let's put it all together:"}),t("ul",{children:[t("li",{children:["Our inputs are:",t("ul",{children:[e("li",{children:"Dimensions of the output array (width and height)"}),e("li",{children:"Major radius of torus"}),e("li",{children:"Minor radius of torus"}),e("li",{children:"Scaling factor for noise"}),e("li",{children:"3D Noise function"})]})]}),t("li",{children:["Our outputs are:",e("ul",{children:e("li",{children:"2D array with specified dimensions containing the noise"})})]})]}),e("p",{children:"Here's the code:"}),t(R,{promise:fe(ve),children:[e(R.Pending,{children:e("div",{className:"spinner-border",role:"status"})}),e(R.Fulfilled,{children:r=>e(pe,{className:"mx-5",language:"typescript",showLineNumbers:!0,style:ge,children:r})}),e(R.Rejected,{children:e("div",{className:"spinner-border",role:"status"})})]}),e("p",{children:"And here's what the texture looks like:"}),e(v,{title:"Wrapping Texture",id:"wrapping-textures-demo",children:e(B,{className:"mx-auto",style:{width:"20em"},aspectRatio:2,texture:L(new j(400,400,(r,i)=>{const a=3,l=2,o=1,u=r/200*Math.PI,h=i/200*Math.PI;return Ae((l+o*Math.cos(u))*Math.cos(h)*a,(l+o*Math.cos(u))*Math.sin(h)*a,o*Math.sin(u)*a)/2+.5})),detailLevel:20,wireframe:!1})}),e("h4",{children:"Overcoming Distortion"}),t("p",{children:["If we look closely at the above demo's texture (when flat), we'll see an interesting phenomenon: the center of the texture looks regular, but the left and right edges seem squished vertically. This is an example of ",e("strong",{children:"distortion"}),", undesirable stretching or squishing that occurs when mapping a 3d surface to a plane."]}),t("p",{children:["In this case, distortion occurs due to the difference between the inner and outer radiuses of the torus. The inner radius is ",e(c,{children:"R - r"})," and the outer radius is ",e(c,{children:"R + r"}),". So, the ratio of stretching that occurs between the inner and outer radiuses is:"]}),e(c,{block:!0,children:String.raw`
          s = \frac {R + r} {R - r}
      `}),e("p",{children:"Essentially, what this tells us is that the lower the aspect ratio, the higher the distortion will be. For relatively low aspect ratios like our torus, the distortion ratio can be large. The torus displayed in the demo has a distortion radius of 3, which is very significant."}),e("p",{children:"Whether or not distortion is a problem depends on the type of game you're building. If you don't use voxels, then its relatively simple to correct. The problem with distortion for voxel video games is that it means that object sizes change depending on where you are on the world. There are 2 potential solutions, and both have problems."}),e("p",{children:"The simplest solution is to simply ignore distortion, and just display a voxel as a meter length cube anywhere on the world. However, this would mean that mountains will look extremely squished on the outer radius, since they would be 3 times narrower in one direction than in the other."}),e("p",{children:"Alternatively, we could scale voxels depending on location in the world. If you stand on the inner radius, a voxel would look normal. However, on the outer radius, that same voxel would appear to be a rectangular prism, 3 times longer than it was wide. This solves the problem of terrain looking squished, since the voxels would be larger to compensate. However, it means that dungeons or player built structures will be heavily distorted."}),e("p",{children:"If the distortion ratio were small enough, the problems could be small enough to ignore. However, with a distortion ratio of 3, these problems must be addressed somehow."}),e("h4",{children:"Cheating using the 4th dimension"}),e("p",{children:"In the following section, we'll describe a method to eliminate distortion. However, it may not be necessary depending on your requirements."}),e("p",{children:"In the last section, we used a 3D noise function to get a texture that wraps across a torus seamlessly. Unfortunately, our texture suffered from distortion, preventing us from using voxels."}),e("p",{children:"It turns out that all toruses have this problem, to varying extents. The fundamental reason why is revealed when we take a look at the parametric equation once again:"}),e(c,{block:!0,children:String.raw`
        r(\theta, \phi) =
        \begin{bmatrix}
          (R + r\cos \theta) \cos \phi \\
          (R + r\cos \theta) \sin \phi \\
          r \sin \theta
        \end{bmatrix}
      `}),t("p",{children:["Notice how changing ",e(c,{math:"\\phi"})," changes both x and y, while changing ",e(c,{math:"\\theta"})," changes x, y and z. There simply aren't enough degrees of freedom for the variables changed by ",e(c,{math:"\\phi"})," be independent from the variables changed by ",e(c,{math:"\\theta"}),". This manifests as the difference between the inner and outer radiuses. When ",e(c,{math:"\\theta = 0"}),", the ring traced by varing ",e(c,{math:"\\phi"})," has a greater radius than when ",e(c,{math:"\\theta = \\pi"}),"."]}),e("p",{children:"In order to get the degree of freedom necessary, we need to add another dimension. OpenSimplex supports up to 4 dimensions, so we're able to do this:"}),e(c,{block:!0,children:"coherentRandom4: \\reals^4  \\to \\reals"}),t("p",{children:["Using this new noise function, we can try to think of a new parameterization of a torus that keeps the variables changed by ",e(c,{math:"\\phi"})," seperate from the variables changed by ",e(c,{math:"\\theta"}),". This turns out to be pretty easy:"]}),e(c,{block:!0,children:String.raw`
        r(\theta, \phi) =
        \begin{bmatrix}
          R \cos \phi \\
          R \sin \phi \\
          r \cos \theta \\
          r \sin \theta
        \end{bmatrix}
      `}),t("p",{children:["You can think of this new 4D torus as a kind of double cylinder. It simultaneously manages to roll up a 2D square by connecting its top and bottom edges, as well as its left and right edges. Varying the ",e(c,{math:"\\phi"})," coordinate traces out a circle in the ",e(c,{children:"xy"})," plane. Varying the ",e(c,{math:"\\theta"})," coordinate traces out a circle in the ",e(c,{children:"zw"})," plane."]}),t("p",{children:["Mathematically, the shape we've described is called a ",e("strong",{children:"flat torus"}),e(s,{source:"https://en.wikipedia.org/wiki/Torus#Flat_torus"}),"."]})]}),e(D,{id:"sources",name:"Sources",children:e(n,{})})]})});me.render(e(b.StrictMode,{children:e(Ee,{})}),document.getElementById("root"));
